---
layout: post
title: 算法：链表学习1
categories: [数据结构算法]
---

### 算法：链表学习1

#### [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4] 
```

ps:

* 设置虚拟头节点，方便处理链表。原头节点用于返回结果
* 链表处理习惯先赋值在链接 如：p.next = node; p = p.next;
* 考虑边界情况是否处理（链表是否需要切断等）

#### [86. 分隔链表](https://leetcode.cn/problems/partition-list/)

给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。

你应当 保留 两个分区中每个节点的初始相对位置。

```
输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]
```

ps:

* 分解成两个链表然后再合并
* 遍历原链表时需要处理链表中每个节点的next指针

#### [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

ps:

* 最难的点是在list列表的头结点中找出最小值
* 使用Java中的PriorityQueue，优先级队列二叉堆处理
* 每次弹出最小的值，并加入该值队列的后一个数，直到队列为空

#### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

ps:

* 如何遍历一次找到倒数第2个节点？（通常申明两个节点，第一个节点先走二，然后一起走直到第一个节点为空，返回第二个节点）
* 删除下一个节点操作：node.next = node.next.next;
* 通常申明节点首元素为-1，来避免空指针的情况，结果返回result.nnext就行